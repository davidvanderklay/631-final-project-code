from leduc_game import LeducState, LeducGame, RANK_CHARS


class ExploitabilityCalculator:
    def __init__(self, game):
        self.game = game

    def compute_exploitability(self, strategy):
        """
        Calculates the exploitability of a strategy profile.
        """
        br_val_p0 = self.get_br_value(0, strategy)
        br_val_p1 = self.get_br_value(1, strategy)
        return (br_val_p0 + br_val_p1) / 2

    def get_br_value(self, br_player, strategy):
        total_value = 0.0
        deck = [0, 1, 2, 3, 4, 5]

        for my_card in deck:
            belief = [1.0 if c != my_card else 0.0 for c in range(6)]

            # Root of game: P0 always starts
            val = self._walk_tree(
                history="",
                bets=[1, 1],
                pot=2,
                round_idx=0,
                current_player=0,
                my_card=my_card,
                board_card=None,
                belief=belief,
                br_player=br_player,
                strategy=strategy,
                is_terminal_state=False,
            )

            total_value += val

        return total_value / 30.0

    def _walk_tree(
        self,
        history,
        bets,
        pot,
        round_idx,
        current_player,
        my_card,
        board_card,
        belief,
        br_player,
        strategy,
        is_terminal_state,
    ):
        """
        Recursive tree walker with state tracking.
        """
        # 1. Construct State
        opp_card_dummy = next(i for i, p in enumerate(belief) if p > 0)
        dummy_cards = [0, 0, 0]
        dummy_cards[br_player] = my_card
        dummy_cards[1 - br_player] = opp_card_dummy
        if board_card is not None:
            dummy_cards[2] = board_card

        # BIG FIX: Pass current_player to constructor
        state = LeducState(
            cards=dummy_cards,
            history=history,
            round_idx=round_idx,
            current_player=current_player,
            bets=bets,
            pot=pot,
            finished=is_terminal_state,
        )

        # 2. Terminal Node
        if state.is_terminal():
            weighted_payoff = 0.0
            for opp_card in range(6):
                if belief[opp_card] > 0:
                    real_cards = list(dummy_cards)
                    real_cards[1 - br_player] = opp_card

                    real_state = LeducState(
                        cards=real_cards,
                        history=history,
                        round_idx=round_idx,
                        current_player=current_player,
                        bets=bets,
                        pot=pot,
                        finished=True,
                    )

                    payoff = real_state.get_payoff()
                    if br_player == 1:
                        payoff = -payoff

                    weighted_payoff += payoff * belief[opp_card]
            return weighted_payoff

        # 3. Chance Node
        if state.round_idx == 1 and board_card is None:
            total_chance_val = 0.0
            boards_count = 0
            for b_card in range(6):
                if b_card == my_card:
                    continue

                new_belief = list(belief)
                if new_belief[b_card] > 0:
                    new_belief[b_card] = 0

                if sum(new_belief) == 0:
                    continue

                total_chance_val += self._walk_tree(
                    history,
                    bets,
                    pot,
                    1,
                    0,
                    my_card,
                    b_card,
                    new_belief,
                    br_player,
                    strategy,
                    is_terminal_state=False,
                )
                boards_count += 1

            return total_chance_val / boards_count

        # 4. Decision Node
        legal_actions = state.get_legal_actions()

        if current_player == br_player:
            # Maximize value
            vals = []
            for action in legal_actions:
                next_state = state.perform_action(action)
                vals.append(
                    self._walk_tree(
                        next_state.history,
                        next_state.bets,
                        next_state.pot,
                        next_state.round_idx,
                        next_state.current_player,  # Pass updated player
                        my_card,
                        board_card,
                        belief,
                        br_player,
                        strategy,
                        is_terminal_state=next_state.finished,
                    )
                )
            return max(vals)

        else:
            # Opponent plays according to strategy
            total_val = 0.0
            next_beliefs = {a: [0.0] * 6 for a in legal_actions}

            for opp_c, weight in enumerate(belief):
                if weight == 0:
                    continue

                opp_rank_char = RANK_CHARS[opp_c // 2]
                if round_idx == 0:
                    infoset_key = f"{opp_rank_char}:{history}"
                else:
                    board_rank_char = RANK_CHARS[board_card // 2]
                    infoset_key = f"{opp_rank_char}:{history}:{board_rank_char}"

                probs = strategy.get(infoset_key, None)
                if probs is None:
                    uniform_prob = 1.0 / len(legal_actions)
                    probs = {a: uniform_prob for a in legal_actions}

                for action in legal_actions:
                    p = probs.get(action, 0.0)
                    if p > 0:
                        next_beliefs[action][opp_c] = weight * p

            for action in legal_actions:
                b_next = next_beliefs[action]
                if sum(b_next) > 0:
                    next_state = state.perform_action(action)
                    total_val += self._walk_tree(
                        next_state.history,
                        next_state.bets,
                        next_state.pot,
                        next_state.round_idx,
                        next_state.current_player,  # updated player
                        my_card,
                        board_card,
                        b_next,
                        br_player,
                        strategy,
                        is_terminal_state=next_state.finished,
                    )

            return total_val


if __name__ == "__main__":
    game = LeducGame()
    calc = ExploitabilityCalculator(game)
    print("Calculating Random Strategy Exploitability...")
    exp = calc.compute_exploitability({})
    print(f"Exploitability: {exp:.4f}")
